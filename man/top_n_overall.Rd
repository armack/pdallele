% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ranking.R
\name{top_n_overall}
\alias{top_n_overall}
\alias{top_n_across_groups}
\alias{top_n_by_group}
\title{Rank, sort, and combine values}
\usage{
top_n_overall(
  data,
  ...,
  count,
  n = 10,
  desc = TRUE,
  other = "Other",
  relevel = "name",
  other_pos = "last"
)

top_n_across_groups(
  data,
  ...,
  count,
  n = 10,
  desc = TRUE,
  other = "Other",
  relevel = "name",
  other_pos = "last"
)

top_n_by_group(
  data,
  ...,
  count,
  n = 10,
  desc = TRUE,
  other = "Other",
  relevel = "name",
  other_pos = "last"
)
}
\arguments{
\item{data}{A data frame or tibble}

\item{...}{\if{html}{\out{<data-masking>}} Columns with 'label' values for \code{count}}

\item{count}{Column of values (typically counts) to rank}

\item{n}{Number of 'labels' to keep per group (all other values will be
collapsed into \code{other})}

\item{desc}{Should the n highest (\code{TRUE}) or lowest (\code{FALSE}) values of
\code{count} be kept?}

\item{other}{Label for the \code{other} group}

\item{relevel}{should the output be releveld based on ... (\code{name}),
values (\code{count}), or not at all (\code{none})?}

\item{other_pos}{Where should \code{other} sort? Options: \code{first} before ranked
values, \code{last} after ranked values, \code{drop} drop all non-ranked values.}
}
\description{
These functions are primarily designed to prepare data for use in
\code{\link[=donut_plot]{donut_plot()}} and serve three main purposes:
\enumerate{
\item Determine the \code{n} largest (or smallest) \code{count}
\item Combine remaining \code{count} into \code{other}
\item Optionally relevel \code{...} using \code{\link[=relevel_numeric]{relevel_numeric()}}
}

They differ in the handling of groups:
\itemize{
\item \code{top_n_overall()} determines the "top n" of the entire dataset and keeps those labels across all groups.
\item \code{top_n_by_group()} determines the "top n" on a group-by-group basis and keeps the "top n" labels for each group independently.
\item \code{top_n_across_groups()} determines the "top n" on a group-by-group basis and keeps labels appearing in the "top n" of any group across all groups.
}

All values that aren't within the 'top n' are combined into \code{other}, which
can be dropped from the output if desired.

No tie-breaking is performed. In the event of a tie for the \code{n}th position,
the first row by \code{arrange(...)} is kept.
}
\section{Output Length}{


Number of rows included in the output tibble willvary based on the function
used and the number of groups \code{group_by(data, ...)} creates.

Assuming each group contains at least \code{n} labels (i.e. \code{group_by(data, ...)}
groups):
\itemize{
\item \code{top_n_overall()} outputs a total of \code{n} distinct labels with all others combined into \code{other}.
\item \code{top_n_by_group()}  outputs a total of \code{n * n_groups(group_by(data, ...))} distinct labels with all others combined into\code{other}.
\item \code{top_n_across_groups()} outputs a maximum of \code{n * n_groups(group_by(data, ...))} distinct labels with all others combined into \code{other}.
}

The exact number of rows output by \code{top_n_across_groups()} will vary based on
the number of shared values of \code{...} between groups, but will always be
between \code{n} (e.g. complete overlap) and \code{n * n_groups(group_by(data, ...))}
(e.g. no overlap).
}

